# file generated by .ui of qt creator
from .Uis.Main_Window_Ui.main_window_ui import *
from bson.objectid import ObjectId
import sys


# GUI library
from PyQt5 import QtCore, QtGui, QtWidgets, Qt

# client for trello
from Functions.trello_api.task_card import *
import trello.member

# invites menu for a group, needs fixing to work properly
from .invites_menu_ext import *

import datetime
import pytz
import dateutil.parser

########################################################################################################################
#                                                         Main Window Class                                            #
########################################################################################################################
class Main_Window(Ui_main_window):

    def __init__(self, db, trello, google):
        super().__init__()

        self.db = db
        self.user = self.db.user
        self.invites_signal = QtCore.pyqtSignal()
        self.current_group = None
        self.current_group_name = None
        self.current_calendar_id = None
        self.user_id = self.db.user.user_id
        self.trello = trello

        # not working
        self.google_client = google
        print(self.google_client)



    def setupUi(self, main_window):
        super().setupUi(main_window)

        #self.invites_menu = QtWidgets.QWidget()
########################################################################################################################
#                                                         Menu bar setup                                               #
########################################################################################################################
        # adding menu bar items
        self.exit_menu = QtWidgets.QMenu("&Exit",main_window)
        self.refresh_menu = QtWidgets.QMenu("&Tools", main_window)
        self.help_menu = QtWidgets.QMenu("&Help",main_window)

        self.menubar.addMenu(self.exit_menu)
        self.menubar.addMenu(self.help_menu)
        self.menubar.addMenu(self.refresh_menu)

        # defining some QActions for menubar - NEED
        self.action1 = QtWidgets.QAction("&Log Out")
        self.action2 = QtWidgets.QAction("&About")
        self.action3 = QtWidgets.QAction("&Refresh")
        self.action3.setShortcut(QtGui.QKeySequence("Ctrl+R"))
        self.action4 = QtWidgets.QAction("&Quit")
        #self.exit_menu.addAction(self.action1)
        self.exit_menu.addAction(self.action4)
        #self.action1.triggered.connect(self.logout)
        self.action4.triggered.connect(self.exit_app)
        self.refresh_menu.addAction(self.action3)
        self.action3.triggered.connect(self.widgets_refresh)

########################################################################################################################
#                                                         Groups Tree model setup                                      #
########################################################################################################################
        # setting group tree model
        self.groups_tree.setHeaderHidden(True)
        self.groups_model = QtGui.QStandardItemModel()
        self.groups_node = self.groups_model.invisibleRootItem()


        self.groups_tree.setModel(self.groups_model)
        self.groups_tree.expandAll()

########################################################################################################################
#                                                         Forum tree model setup                                       #
########################################################################################################################
        # setting forum tree model
        self.forum_tree.setHeaderHidden(True)
        self.forum_model = QtGui.QStandardItemModel()
        self.forum_node = self.forum_model.invisibleRootItem()

        self.forum_tree.setModel(self.forum_model)
        self.forum_tree.expandAll()

########################################################################################################################
#                                                         trello tree model setup                                      #
########################################################################################################################
        self.trello_tree.setHeaderHidden(True)
        self.trello_model = QtGui.QStandardItemModel()
        self.trello_node = self.trello_model.invisibleRootItem()

        self.trello_tree.setModel(self.trello_model)
        self.trello_tree.expandAll()

########################################################################################################################
#                                                         docs tree model setup                                      #
########################################################################################################################
        self.docs_tree.setHeaderHidden(True)
        self.docs_model = QtGui.QStandardItemModel()
        self.docs_node = self.docs_model.invisibleRootItem()

        self.docs_tree.setModel(self.docs_model)
        self.docs_tree.expandAll()

########################################################################################################################
#                                                         error frame hiding                                           #
########################################################################################################################
        # hiding all error frames
        self.groups_error_frame.hide()
        self.forums_error_frame.hide()
        self.calendar_error_frame.hide()
        self.tasks_error_frame.hide()
        self.docs_error_frame.hide()

########################################################################################################################
#                                                         connecting all buttons                                       #
########################################################################################################################
        #connecting buttons
        self.connect_all_error_frames()
        self.connect_groups_buttons()
        self.connect_forums_buttons()
        self.connect_calendar_buttons()
        self.connect_tasks_buttons()
        self.connect_docs_buttons()

        # call to populate widgets with users information
        # groups tree, invites, forum, calendar events, trello, and group documents
        #self.widgets_refresh()
        # now to get the timer started
        self.widgets_timer = QtCore.QTimer()
        self.widgets_timer.timeout.connect(self.widgets_refresh)

########################################################################################################################
#                                               connecting all buttons function                                        #
########################################################################################################################

    # connecting all error closing buttons
    def connect_all_error_frames(self):
        self.groups_close_popup_button.clicked.connect(lambda:self.error_frame_hide(self.groups_error_frame))
        self.forums_close_popup_button.clicked.connect(lambda:self.error_frame_hide(self.forums_error_frame))
        self.calendar_close_popup_button.clicked.connect(lambda:self.error_frame_hide(self.calendar_error_frame))
        self.tasks_close_popup_button.clicked.connect(lambda:self.error_frame_hide(self.tasks_error_frame))
        self.docs_close_popup_button.clicked.connect(lambda:self.error_frame_hide(self.docs_error_frame))


    # connecting all group tab buttons
    def connect_groups_buttons(self):
        self.create_group_button.clicked.connect(self.create_group)
        self.invite_button.clicked.connect(self.invite_members)
        self.delete_group_button.clicked.connect(self.delete_group)
        self.accept_invite_button.clicked.connect(self.accept_invite)
        self.remove_user_edit.clicked.connect(self.remove_user)
        self.decline_invite_button.clicked.connect(self.decline_invite)
        self.groups_tree.clicked.connect(self.view_group_description)


    # connecting all forum tab buttons
    def connect_forums_buttons(self):
        self.message_button.clicked.connect(self.send_message)
        self.forum_tree.clicked.connect(self.forum_change)
        self.delete_post_button.clicked.connect(self.remove_post)



    # connecting all calendar tab buttons
    def connect_calendar_buttons(self):
        self.add_event_button.clicked.connect(self.add_event)
        self.calendar.clicked.connect(self.calendar_buttons)
        self.months_list.clicked.connect(self.get_days_event)
        self.delete_event_button.clicked.connect(self.delete_event)


    # connecting all task tab buttons
    def connect_tasks_buttons(self):
        self.add_list_button.clicked.connect(self.add_list)
        self.delete_list_button.clicked.connect(self.delete_list)
        self.move_card_button.clicked.connect(self.move_card)
        self.edit_task_description_button.clicked.connect(self.edit_description)
        self.delete_task_button.clicked.connect(self.delete_task)
        self.card_add_button.clicked.connect(self.add_task)
        self.trello_tree.clicked.connect(self.get_description)


    # connecting all doc tab buttons
    def connect_docs_buttons(self):
        self.doc_create_button.clicked.connect(self.create_doc)
        self.doc_share_button.clicked.connect(self.share_link)
        self.doc_delete_button.clicked.connect(self.delete_doc)
        self.document_list.itemDoubleClicked.connect(self.hyperlink_doc)
        self.docs_tree.clicked.connect(self.get_docs_group)


    def widgets_refresh(self):
        self.widgets_timer.stop()
        print("refreshing")
        self.populate_groups_tree(self.groups_tree, self.groups_model, self.groups_node)
        print("populated groups_tree")
        self.populate_groups_tree(self.forum_tree, self.forum_model, self.forum_node)
        print("populated forum_tree")
        self.populate_groups_tree(self.docs_tree, self.docs_model, self.docs_node)
        print("populated docs_tree")
        self.get_group_documents()
        print("get_group_docs")
        self.set_trello_tree()
        print("setting trello tree")
        self.get_invites()
        print("getting invites")
        self.get_months_events()
        print("getting months events")
        self.widgets_timer.start(30000)


    # error displaying func - don't really need but wth
    def error_frame_show(self, error_frame):
        error_frame.setVisible(True)


    # error hiding func - ^ you know what's up there
    def error_frame_hide(self, error_frame):
        error_frame.setVisible(False)

    def set_current_group(self, group_id):
        self.current_group = group_id
        self.user.currentGroup = ObjectId(group_id)
        self.current_group_name = self.db.group_lookup(self.user.currentGroup)['group_name']
        self.current_calendar_id = self.db.group_lookup(self.user.currentGroup)['calendar_id']
        self.get_months_events()

    def logout(self):
        sys.exit(0)

    def exit_app(self):
        sys.exit(0)
########################################################################################################################
#                                               Groups Tab                                                             #
########################################################################################################################

    # group create button function
    def create_group(self):
        # getting edit data
        group_name = self.group_name_edit.text()
        group_description = self.group_description_edit.toPlainText()
        group_invites = self.email_edit.toPlainText().split(',')

        # parse input
        if group_name+group_description == "":
            error_text = "Missing group name/group description"
            self.groups_error_label.setText(error_text)
            self.error_frame_show(self.groups_error_frame)

        elif group_name != "" and group_description == "":
            error_text = "Missing group description"
            self.groups_error_label.setText(error_text)
            self.error_frame_show(self.groups_error_frame)

        elif group_name == "" and group_description != "":
            error_text = "Missing group name"
            self.groups_error_label.setText(error_text)
            self.error_frame_show(self.groups_error_frame)

        else:
            # clearing edits
            self.group_name_edit.clear()
            self.group_description_edit.clear()
            self.email_edit.clear()

            # creating group with or without invites
            if group_invites[0] == '':
                print("creating group")
                calendar_id = self.google_client.google_calendar.CreateCalendar(group_name, 'America/New_York')
                print("calendar id: ", calendar_id)
                self.db.create_group(group_name, group_description, calendar_id)
                groups = self.db.get_groups()
                for group in groups:
                    if group['group_name'] == group_name:
                        self.set_current_group(group['_id'])
                        print(group['_id'])
                        print("got it")
                        id = group['calendar_id']
                        print(id)
                        #self.db.get_calendar_id()

                print("setting up trello")
                # set up single trello board for group
                self.trello.ping_board_create(group_name)
                print("trello set up")

                print("updating tree")
                self.populate_groups_tree(self.groups_tree, self.groups_model, self.groups_node)
                print("updated")



            else:
                calendar_id = self.google_client.google_calendar.CreateCalendar(group_name, 'America/New_York')
                print("calendar id: ", calendar_id)
                self.db.create_group(group_name, group_description, calendar_id)
                groups = self.db.get_groups()
                for group in groups:
                    if group['group_name'] == group_name:
                        self.set_current_group(group['_id'])
                        print("got it")
                        id = group['calendar_id']
                        print(id)
                        # self.db.get_calendar_id()
                self.trello.ping_board_create(group_name)
                self.populate_groups_tree(self.groups_tree, self.groups_model, self.groups_node)
                self.send_invites(group_invites)

    # invite member button function
    # -currently not working
    def invite_members(self):
        index = self.groups_tree.currentIndex()

        if index.data() == None:
            error_text = "No group selected"
            self.groups_error_label.setText(error_text)
            self.error_frame_show(self.groups_error_frame)

        else:
            self.invites_menu = QtWidgets.QWidget()
            self.invites_menu_ui = invites_menu_ext(self.invites_signal, self)
            self.invites_menu_ui.setupUi(self.invites_menu)
            #self.invites_signal.connect(lambda: self.send_invites(self.invites_menu.send_invites_edit))

            self.invites_menu.show()



    # delete group button function
    # currently not connected to the db
    def delete_group(self):
        index = self.groups_tree.currentIndex()

        if index.data() == None:
            error_text = "Select a group to delete"
            self.groups_error_label.setText(error_text)
            self.error_frame_show(self.groups_error_frame)

        else:
            item = self.groups_model.itemFromIndex(index)

            if item.role == "group" and self.db.check_ownership(item.group_id, self.db.user._id):
                print("deleting the group")
                self.db.delete_group()

            elif item.role == "group" and self.db.check_ownership(item.group_id, self.db.user._id) == 0:
                error_text = "You are not the owner of " + item.text()
                self.groups_error_label.setText(error_text)
                self.error_frame_show(self.groups_error_frame)

            elif item.role == "owner" or item.role == "member":
                if self.db.check_ownership(item.parent().group_id, self.db.user._id):
                    print("removing group")
                    self.db.delete_group()


                else:
                    error_text = "You are not the owner of " + item.parent().text()
                    self.groups_error_label.setText(error_text)
                    self.error_frame_show(self.groups_error_frame)

    def remove_user(self):
        index = self.groups_tree.currentIndex()

        if index.data() == None:
            error_text = "Select a user to remove"
            self.groups_error_label.setText(error_text)
            self.error_frame_show(self.groups_error_frame)

        else:
            item = self.groups_model.itemFromIndex(index)

            print("role", item.role)
            print("group id", item.group_id)
            print("calendar_id", item.calendar_id)
            print("current_group_id", self.current_group)
            print("user id", self.db.user._id)

            if item.role == "group" and self.db.check_ownership(item.group_id, self.db.user._id):
                error_text = "Select a user to remove from " + item.text()
                self.groups_error_label.setText(error_text)
                self.error_frame_show(self.groups_error_frame)

            elif item.role == "group" and self.db.check_ownership(item.group_id, self.db.user._id) == 0:
                error_text = "You are not the owner of " + item.text()
                self.groups_error_label.setText(error_text)
                self.error_frame_show(self.groups_error_frame)

            elif item.role == "owner" or item.role == "member":
                if self.db.check_ownership(item.parent().group_id, self.db.user._id):
                    if item.role == "owner":
                        print("You can't remove yourself")
                        error_text = "You can't remove yourself from " + item.parent().text()
                        self.groups_error_label.setText(error_text)
                        self.error_frame_show(self.groups_error_frame)

                    else:
                        self.db.remove_user(ObjectId(item.group_id))
                        print("removing member")

                else:
                    error_text = "You are not the owner of " + item.parent().text()
                    self.groups_error_label.setText(error_text)
                    self.error_frame_show(self.groups_error_frame)





            #elif item.role == "member" and self.

    # return all invites the user has
    def get_invites(self):
        self.invites_list.clear()
        invites = self.db.user_lookup(self.user._id)['invites']
        print(invites)
        if len(invites) != 0:
            for group in invites:
                #print(group)
                print(group['group_id'])
                invite_group = self.db.group_lookup(group['group_id'])
                print("invite", invite_group)
                group_name = invite_group['group_name']
                print("shit")
                print(invite_group['calendar_id'])

                invite = InvitesListItem(group_name, group['sender'], group['group_id'], invite_group['calendar_id'])
                self.invites_list.addItem(invite)



    # accept invite button function
    # accept an invite to a group
    # currently not connected to the db
    def accept_invite(self):
        invites = self.invites_list.selectedItems()
        if len(invites) == 1:
            self.db.invite_accept(invites[0].group_id)
            self.google_client.google_calendar.addAccessRule(invites[0].calendar_id, self.db.user.user_id)
            self.google_client.google_calendar.AddToCalendarList(invites[0].calendar_id)
            self.get_invites()
            """invite = self.invites_list.takeItem(self.invites_list.row(self.invites_list.currentItem()))
            self.groups_node.appendRow(StandardItem(invite.text()))"""
            print("Wheew made it out")

        else:
            error_text = "No invite selected to accept"
            self.groups_error_label.setText(error_text)
            self.error_frame_show(self.groups_error_frame)


    # decline invite button function
    # decline an invite to a group
    # not currently connected to the db
    def decline_invite(self):
        invite = self.invites_list.selectedItems()
        if len(invite) == 1:
            self.db.invite_deny(invite[0].group_id)


        else:
            error_text = "No invite selected to decline"
            self.groups_error_label.setText(error_text)
            self.error_frame_show(self.groups_error_frame)


    # connected to groups_tree
    # get description of group from either the group item or member item and output to screen
    # i guess anything that is connected to a tree widget passes the index selected automatically
    # set current group -added
    def view_group_description(self, index):
        self.group_description_view.clear()
        item = self.groups_model.itemFromIndex(index)

        if item.role == "group":
            self.group_description_view.insertPlainText(item.description)
            self.set_current_group(item.group_id)

        elif item.role == "member" or item.role == "owner":
            self.group_description_view.insertPlainText(item.parent().description)
            self.set_current_group(item.parent().group_id)


    # populate the group tree widget from db
    # realized i can repurpose this to also update the forums groups section
    def populate_groups_tree(self,tree, model, node):
        model.clear()
        node = model.invisibleRootItem()
        tree.setModel(model)
        tree.expandAll()

        groups = self.db.get_groups()

        for group in groups:
            new_group = StandardItem(group['group_name'], "group", group['description'], str(group['_id']),group['calendar_id'])
            owner = self.db.user_lookup(group['owner'])
            group_owner = StandardItem(owner['user_name'], "owner", None, str(group['owner']))
            new_group.appendRow(group_owner)
            members = group['members']
            members.remove(group['owner'])

            for member in members:
                member_name = self.db.user_lookup(member)
                new_group.appendRow(StandardItem(member_name['user_name'], 'member', None, str(member)))

            node.appendRow(new_group)

    def send_invites(self, group_invites):
        for member in group_invites:
            member = member.strip()
            print(member)
            member_doc = self.db.user_lookup_by_email(member)
            if member_doc:

                member_info = trello.member.Member(self.trello.client, member_doc['trello_id'])
                print(member_info)
                print("Sending invites")
                if self.db.send_invite(member_doc['_id']):
                    print(member_doc['user_id'])
                    boards = self.trello.ping_boards()
                    print(boards)
                    for board in boards:
                        if(board.name == self.current_group_name):
                            print("adding members")
                            board.add_member(member_info, member_type='admin')
                            print("added")
            else:
                error_text = "Some users were not found"
                self.groups_error_label.setText(error_text)
                self.error_frame_show(self.groups_error_frame)



########################################################################################################################
#                                               Forums Tab                                                             #
########################################################################################################################

    # post a message to the database and repopulate the forum
    def send_message(self):
        # owner should be changed to User.name
        owner = self.db.user.name
        time = datetime.datetime.now().strftime("%H:%M:%S")
        message = self.message_edit.toPlainText()

        if message == "":
            error_text = "Enter a message to send to the group"
            self.forums_error_label.setText(error_text)
            self.error_frame_show(self.forums_error_frame)

        elif self.current_group == None:
            error_text = "Select a group to send a message to"
            self.forums_error_label.setText(error_text)
            self.error_frame_show(self.forums_error_frame)

        elif message == "" and self.current_group == None:
            error_text = "Select a group / Enter a message to the group"
            self.forums_error_label.setText(error_text)
            self.error_frame_show(self.forums_error_frame)

        else:
            self.message_edit.clear()
            self.db.send_post(message)
            self.populate_forum_view()
            # self.forum_view.insertPlainText((owner+"("+time+"): "+message)+"\n")


    # whenever a group is selected, the forum group label will change and the forum view repopulate
    def forum_change(self):
        index = self.forum_tree.currentIndex()

        if (self.forum_model.parent(index).data() == None):
            self.set_current_group(self.forum_model.itemFromIndex(index).group_id)
            self.group_in_label.setText(index.data())
            self.populate_forum_view()

        elif index == None:
            self.group_in_label.setText("No Group selected")


    # remove post
    def remove_post(self):
        item = self.forum_view.currentItem()
        print("Removing post")
        print(item)
        print(self.current_group)
        if item == None:
            print("No item selected")
            error_text = "No post selected"
            self.forums_error_label.setText(error_text)
            self.error_frame_show(self.forums_error_frame)

        elif self.db.check_ownership(self.current_group, self.db.user._id):
            print("You are the owner")
            if item:
                self.db.delete_post(item._id)
                self.populate_forum_view()
            else:
                print("You are the owner but you didnt select anything")
                error_text = "No post selected"
                self.forums_error_label.setText(error_text)
                self.error_frame_show(self.forums_error_frame)

        elif self.db.check_ownership(self.current_group, self.db.user._id) == 0:
            error_text = "You are not the owner"
            self.forums_error_label.setText(error_text)
            self.error_frame_show(self.forums_error_frame)

    # get all forum posts from db for a particular group
    # probably should be from self.current_group
    # time format not included in the message
    # formatting between messages not included
    def populate_forum_view(self):
        self.forum_view.clear()
        print("populating_forum_view")
        messages = self.db.retrieve_all_posts()
        for message in messages:
            user = self.db.user_lookup(message['author'])['user_name']
            self.forum_view.addItem(ForumListItem(message['_id'], user, message['message'], "Null"))
            #self.forum_view.(user + ":  " + message['message']+"\n")

########################################################################################################################
#                                               Calendar Tab                                                           #
########################################################################################################################

    # Yet to be worked on, only parsing for empty strings
    def add_event(self):
        #datetime.datetime.date(event_year, event_month, event_day).replace(microsecond=0).isoformat()

        event_date = self.date_edit.date()
        event_year = event_date.year()
        event_month = event_date.month()
        event_day = event_date.day()
        time_zone = pytz.timezone('America/New_York')
        start_time = datetime.datetime(event_year,event_month,event_day,0,0,0,0)
        end_time = datetime.datetime(event_year, event_month, event_day+1, 0, 0, 0, 0)
        time_zone.localize(start_time)
        time_zone.localize(end_time)
        event_name = self.event_name_edit.text()
        event_description = self.event_description_edit.toPlainText()

        if event_name + event_description == "":
            error_text = "Missing event name/event description"
            self.calendar_error_label.setText(error_text)
            self.error_frame_show(self.calendar_error_frame)

        elif event_name == "" and event_description != "":
            error_text = "Missing event name"
            self.calendar_error_label.setText(error_text)
            self.error_frame_show(self.calendar_error_frame)

        elif event_name != "" and event_description == "":
            error_text = "Missing event description"
            self.calendar_error_label.setText(error_text)
            self.error_frame_show(self.calendar_error_frame)

        elif self.current_calendar_id == None:
            error_text = "No group selected"
            self.calendar_error_label.setText(error_text)
            self.error_frame_show(self.calendar_error_frame)
        # might need to add date edit checker
        else:
            print("creating an event")
            print(self.current_calendar_id)
            self.event_name_edit.clear()
            self.event_description_edit.clear()
            print(self.current_calendar_id)
            self.google_client.google_calendar.CreateEvent(self.current_calendar_id, event_name, event_description, start_time.isoformat(), end_time.isoformat(), 'America/New_York')
            self.get_months_events()
            print("event was created")

    def calendar_buttons(self):
        self.set_date_edit()


    def set_date_edit(self):
        # print(self.calendar.selectedDate())
        self.date_edit.setDate(self.calendar.selectedDate())

    def get_months_events(self):
        if self.current_group != None:
            self.months_list.clear()
            print("getting months events")
            print(self.current_calendar_id)
            year = self.calendar.selectedDate().year()
            month = self.calendar.selectedDate().month()
            date1 = datetime.datetime(year, month, 1, 0, 0, 0, 0, pytz.timezone('US/Eastern'))
            date2 = datetime.datetime(year, month+1, 1, 0, 0, 0, 0, pytz.timezone('US/Eastern'))
            events = self.google_client.google_calendar.getMonthEvents(self.current_calendar_id, date1.isoformat(), date2.isoformat())
            print(events)
            if len(events) != 0:
                print("adding events")
                for event in events:
                    date = dateutil.parser.isoparse(event['start']['dateTime'])
                    year = date.year
                    month = date.month
                    day = date.day
                    date_string = str(month) + "/" + str(day) + "    " + event['summary']
                    #print(date_string)
                    #print(date)
                    new_event = CalendarListItem(date_string, event)
                    #print(new_event.event_name)
                    self.months_list.addItem(new_event)
            print("end of getting months events")


    def get_days_event(self):
        item = self.months_list.currentItem()
        if item != None:
            self.todays_list.clear()
            date = dateutil.parser.isoparse(item.event['start']['dateTime'])
            event_text = "Event name:             " + item.event['summary'] + "\n" +\
                         "Date:                        " + str(date.month) + "/" +str(date.day) + "/" + str(date.year) + "\n" +\
                         "Event Description:    " + item.event['description'] + "\n"

            self.todays_list.setPlainText(event_text)


    def delete_event(self):
        item = self.months_list.currentItem()

        if self.current_group == None:
            error_text = "Select a group to delete events from"
            self.calendar_error_label.setText(error_text)
            self.error_frame_show(self.calendar_error_frame)

        elif item == None:
            error_text = "Select an event to delete"
            self.calendar_error_label.setText(error_text)
            self.error_frame_show(self.calendar_error_frame)

        elif item != None:
            print(item.event)
            print(self.current_calendar_id)
            self.google_client.google_calendar.DeleteEvent(self.current_calendar_id, item.event['id'])
            self.get_months_events()
            self.todays_list.clear()





########################################################################################################################
#                                               Tasks Tab                                                              #
########################################################################################################################

    # add a list to the trello client
    def add_list(self):
        list_name = self.add_list_edit.text()
        duplicate = self.trello_model.findItems(list_name, QtCore.Qt.MatchExactly)

        if self.current_group != None:
            if list_name == "":
                error_text = "Missing a list name to add"
                self.tasks_error_label.setText(error_text)
                self.error_frame_show(self.tasks_error_frame)

            elif list_name != "":
                if len(duplicate) == 0:
                    self.add_list_edit.clear()
                    self.trello.ping_list_create(self.current_group_name, list_name)

                else:
                    error_text = "List " + list_name + " already exists"
                    self.tasks_error_label.setText(error_text)
                    self.error_frame_show(self.tasks_error_frame)
        else:
            error_text = "No group selected"
            self.tasks_error_label.setText(error_text)
            self.error_frame_show(self.tasks_error_frame)


    # delete a list to the trello client
    # not yet connected to trello
    def delete_list(self):
        list_name = self.add_list_edit.text()
        duplicate = self.trello_model.findItems(list_name, QtCore.Qt.MatchExactly)

        if list_name == "":
            error_text = "Missing a list name to delete"
            self.tasks_error_label.setText(error_text)
            self.error_frame_show(self.tasks_error_frame)

        elif list_name != "":
            self.trello.ping_list_delete(self.current_group_name, list_name)
            self.set_trello_tree()


        else:
            error_text = list_name + " doesn't exist"
            self.tasks_error_label.setText(error_text)
            self.error_frame_show(self.tasks_error_frame)


    # move a card to another list
    def move_card(self):
        list_from = self.list_move_from_edit.text()
        card_from = self.card_move_edit.text()
        list_to = self.list_move_to_edit.text()

        if self.current_group != None:

            if list_from+card_from+list_to == "":
                error_text = "Missing list(from) / task card / list(to)"
                self.tasks_error_label.setText(error_text)
                self.error_frame_show(self.tasks_error_frame)

            elif list_from != "" and card_from+list_to == "":
                error_text = "Missing task card / list(to)"
                self.tasks_error_label.setText(error_text)
                self.error_frame_show(self.tasks_error_frame)

            elif card_from != "" and list_from+list_to == "":
                error_text = "Missing list(from) / list(to) "
                self.tasks_error_label.setText(error_text)
                self.error_frame_show(self.tasks_error_frame)

            elif list_to != "" and list_from+card_from == "":
                error_text = "Missing list(from) / task card"
                self.tasks_error_label.setText(error_text)
                self.error_frame_show(self.tasks_error_frame)

            elif list_from != "" and card_from != "" and list_to == "":
                error_text = "Missing list(to)"
                self.tasks_error_label.setText(error_text)
                self.error_frame_show(self.tasks_error_frame)

            elif list_from != "" and list_to != "" and card_from == "":
                error_text = "Missing task card"
                self.tasks_error_label.setText(error_text)
                self.error_frame_show(self.tasks_error_frame)

            elif card_from != "" and list_to != "" and list_from == "":
                error_text = "Missing list(from)"
                self.tasks_error_label.setText(error_text)
                self.error_frame_show(self.tasks_error_frame)

            else:
                self.list_move_from_edit.clear()
                self.card_move_edit.clear()
                self.list_move_to_edit.clear()

                self.trello.ping_card_move(self.current_group_name, list_from, card_from, list_to)

        else:
            error_text = "No group selected"
            self.tasks_error_label.setText(error_text)
            self.error_frame_show(self.tasks_error_frame)


    # change a cards description
    def edit_description(self):
        index = self.trello_tree.currentIndex()

        if index.data() == None:
            error_text = "Select a task card to edit"
            self.tasks_error_label.setText(error_text)
            self.error_frame_show(self.tasks_error_frame)

        elif index.data() != None:
            if self.trello_model.itemFromIndex(index).role != "card":
                error_text = "Select a task card to edit"
                self.tasks_error_label.setText(error_text)
                self.error_frame_show(self.tasks_error_frame)

            else:
                if self.edit_task_description_button.text() == "Edit Description":
                    self.task_card_view.setReadOnly(False)
                    self.edit_task_description_button.setText("Save Description")

                elif self.edit_task_description_button.text() == "Save Description":
                    item = self.trello_model.itemFromIndex(index)
                    self.trello.ping_card_modify(self.current_group_name, item.parent().text(), item.text(),self.task_card_view.toPlainText())
                    self.task_card_view.setReadOnly(True)
                    self.edit_task_description_button.setText("Edit Description")


    # delete a task card from a list
    # not yet connected to trello
    def delete_task(self):
        index = self.trello_tree.currentIndex()

        if index.data() == None:
            error_text = "Select a task card to delete"
            self.tasks_error_label.setText(error_text)
            self.error_frame_show(self.tasks_error_frame)

        elif index.data() != None:
            if self.trello_model.itemFromIndex(index).role != "card":
                error_text = "Select a task card to delete"
                self.tasks_error_label.setText(error_text)
                self.error_frame_show(self.tasks_error_frame)


            else:
                self.trello.ping_card_delete(self.current_group_name, index.parent().data(), index.data())
                self.set_trello_tree()



    # add a task card to a list
    # not yet connected to trello
    def add_task(self):
        list_name = self.card_add_list_edit.text()
        card_name = self.card_add_edit.text()
        task_description = self.card_description_edit.toPlainText()

        if list_name+card_name+task_description == "":
            error_text = "Missing list name / task card name / task card description"
            self.tasks_error_label.setText(error_text)
            self.error_frame_show(self.tasks_error_frame)


        elif list_name != "" and card_name+task_description == "":
            error_text = "Missing task card name / task card description"
            self.tasks_error_label.setText(error_text)
            self.error_frame_show(self.tasks_error_frame)

        elif card_name != "" and list_name+task_description == "":
            error_text = "Missing list name / task card description"
            self.tasks_error_label.setText(error_text)
            self.error_frame_show(self.tasks_error_frame)

        elif task_description != "" and list_name+card_name == "":
            error_text = "Missing list name / task card name"
            self.tasks_error_label.setText(error_text)
            self.error_frame_show(self.tasks_error_frame)

        elif list_name != "" and card_name+task_description == "":
            error_text = "Missing task card name / task card description"
            self.tasks_error_label.setText(error_text)
            self.error_frame_show(self.tasks_error_frame)

        elif card_name != "" and list_name+task_description == "":
            error_text = "Missing list name / task card description"
            self.tasks_error_label.setText(error_text)
            self.error_frame_show(self.tasks_error_frame)

        elif task_description != "" and list_name+card_name == "":
            error_text = "Missing list name / task card name"
            self.tasks_error_label.setText(error_text)
            self.error_frame_show(self.tasks_error_frame)

        elif list_name != "" and card_name != "" and task_description == "":
            error_text = "Missing task card description"
            self.tasks_error_label.setText(error_text)
            self.error_frame_show(self.tasks_error_frame)

        elif list_name != "" and task_description != "" and card_name == "":
            error_text = "Missing task card name"
            self.tasks_error_label.setText(error_text)
            self.error_frame_show(self.tasks_error_frame)

        elif card_name != "" and task_description != "" and list_name == "":
            error_text = "Missing list name"
            self.tasks_error_label.setText(error_text)
            self.error_frame_show(self.tasks_error_frame)

        else:
            # add task card to trello
            # update function
            print("card added")
            self.trello.ping_card_create(self.current_group_name, list_name, card_name, task_description)
            self.set_trello_tree()


    # get all trello boards, lists, and task cards to insert
    # pretty sure n^3 is what is making it run slow, not the connection to trello
    # would be better to run as something else lol
    def set_trello_tree(self):
        self.trello_model.clear()
        self.trello_node = self.trello_model.invisibleRootItem()
        self.trello_tree.setModel(self.trello_model)
        self.trello_tree.expandAll()
        if self.current_group != None:
            board = StandardItem(self.current_group_name, "board")
            lists = self.trello.ping_lists(self.current_group_name)
            print(lists)

            for list in lists:
                new_list = StandardItem(list.name, "list")

                for card in self.trello.ping_cards(self.current_group_name, list.name):
                    new_card = StandardItem(card.name, "card", card.desc)
                    new_list.appendRow(new_card)
                board.appendRow(new_list)
            self.trello_node.appendRow(board)

        else:
            print("No group selected")


    # when a user clicks on a task card this function runs
    # checking what mode the edit task button is in
    # wont allow a user to click on another card while editing the description
    def get_description(self, index):
        if self.edit_task_description_button.text() == "Save Description":
            error_text = "Save your task card description before you select another task card"
            self.tasks_error_label.setText(error_text)
            self.error_frame_show(self.tasks_error_frame)

        else:
            if self.trello_model.itemFromIndex(index).role == "card":
                self.task_card_view.clear()
                self.task_card_view.insertPlainText(self.trello_model.itemFromIndex(index).description)


########################################################################################################################
#                                               Docs Tab                                                               #
########################################################################################################################

    # create a new google doc
    # not yet connected to the db or gdrive
    def create_doc(self):
        # get data from edits
        doc_name = self.doc_create_edit.text()

        # list of all docs that match the name edit data
        docs = self.document_list.findItems(doc_name, QtCore.Qt.MatchExactly)

        if self.current_group == None:
            error_text = "You are not in a group"
            self.docs_error_label.setText(error_text)
            self.error_frame_show(self.docs_error_frame)

        elif doc_name == "":
            error_text = "Enter a name for the new document"
            self.docs_error_label.setText(error_text)
            self.error_frame_show(self.docs_error_frame)

        else:
            if len(docs) != 0:
                error_text = "Document name already exists."
                self.docs_error_label.setText(error_text)
                self.error_frame_show(self.docs_error_frame)

            else:
                # clear edits
                self.doc_create_edit.clear()
                self.add_link(doc_name, "create")


    # share a user populated link
    # the user must use the https:// format to any link
    # not yet connected to the database
    def share_link(self):
        # get data from edits
        doc_name = self.doc_share_name_edit.text()
        doc_link = self.doc_share_link_edit.text()

        # list of all docs that match the name edit data
        docs = self.document_list.findItems(doc_name, QtCore.Qt.MatchExactly)

        if self.current_group == None:
            error_text = "You are not in a group"
            self.docs_error_label.setText(error_text)
            self.error_frame_show(self.docs_error_frame)

        elif doc_name + doc_link == "":
            error_text = "Enter a name and a link to share."
            self.docs_error_label.setText(error_text)
            self.error_frame_show(self.docs_error_frame)

        elif doc_name == "" and doc_link != "":
            error_text = "Enter a name to share link."
            self.docs_error_label.setText(error_text)
            self.error_frame_show(self.docs_error_frame)

        elif doc_name != "" and doc_link == "":
            error_text = "Enter a link to share."
            self.docs_error_label.setText(error_text)
            self.error_frame_show(self.docs_error_frame)

        else:
            if len(docs) != 0:
                error_text = "Document name already exists."
                self.docs_error_label.setText(error_text)
                self.error_frame_show(self.docs_error_frame)

            else:
                # clear edits
                self.doc_share_name_edit.clear()
                self.doc_share_link_edit.clear()
                self.add_link(doc_name, "share", doc_link)


    # deletes the document by name
    # not yet connected to the database
    def delete_doc(self):
        # get data from edits
        doc_name = self.doc_delete_edit.text()

        # list of all docs that match the name edit data
        docs = self.document_list.findItems(doc_name, QtCore.Qt.MatchExactly)

        if self.current_group == None:
            error_text = "You are not in a group"
            self.docs_error_label.setText(error_text)
            self.error_frame_show(self.docs_error_frame)

        elif doc_name == "":
            error_text = "Enter the name of a doc you want to delete"
            self.docs_error_label.setText(error_text)
            self.error_frame_show(self.docs_error_frame)

        else:

            if len(docs) == 0:
                error_text = "No document by the name "+doc_name
                self.docs_error_label.setText(error_text)
                self.error_frame_show(self.docs_error_frame)

            else:
                # clear edits
                self.doc_delete_edit.clear()
                for doc in docs:
                    print(doc)
                    self.document_list.takeItem(self.document_list.row(doc))
                    if doc.doc_type == "doc":
                        self.google_client.google_drive.trash_files(doc)
                    self.db.delete_doc(doc._id)

    # helper function to insert a document to the list widget
    # not yet connected to the database
    def add_link(self, doc_name, doc_type, doc_url=None):
        if doc_type == "create":
            # add doc to database
            print("making the doc")
            doc_url = self.google_client.google_drive.create(doc_name)
            self.db.document_add(doc_name, "doc", doc_url)
            self.get_group_documents()
            print("doc added")

        elif doc_type == "share":
            self.db.document_add(doc_name, "link", doc_url)
            self.get_group_documents()


    # if a document is double clicked on the url will be opened
    def hyperlink_doc(self):
        for doc in self.document_list.selectedItems():
            if doc.url != None:
                QtGui.QDesktopServices.openUrl(doc.url)

            else:
                pass


    # populate the docs list if a group is selected in the docs tree
    def get_docs_group(self):
        index = self.docs_tree.currentIndex()

        if index != None:
            item = self.docs_model.itemFromIndex(index)
            if item.role == "group":
                self.set_current_group(item.group_id)

            else:
                self.set_current_group(item.parent().group_id)
            self.get_group_documents()

    # get all documents from db
    def get_group_documents(self):
        self.document_list.clear()
        if self.current_group != None:
            documents = self.db.retrieve_docs()
            self.populate_docs_list(documents)
        else:
            print("not in a group")

    def populate_docs_list(self, documents):
        for doc in documents:
            new_doc = DocListItem(doc['title'], doc['type'], doc['_id'], doc['doc'])
            self.document_list.addItem(new_doc)


# QListWidgetItem for groups list
# may not be needed
class GroupsListItem(Qt.QListWidgetItem):
    def __init__(self, user_name, group_name):
        super().__init__(group_name)
        self.user_name = user_name

# Extension of QListWidgetItem to include link for document
# Used for insertion in the documents tab QListWidget self.document_list
class DocListItem(Qt.QListWidgetItem):
    def __init__(self, text, doc_type=None, _id=None, url=None):
        super().__init__(text)
        self.doc_type = doc_type
        self._id = _id
        self.url = QtCore.QUrl(url)

class CalendarListItem(Qt.QListWidgetItem):
    def __init__(self, event_name, event_json):
        super().__init__(event_name)
        self.event_name = event_name
        self.event = event_json

class ForumListItem(Qt.QListWidgetItem):
    def __init__(self, _id, author, message, time):
        super().__init__((author + ": "+ message))
        self._id = _id
        self.author = author
        self.message = message
        self.time = time

class InvitesListItem(Qt.QListWidgetItem):
    def __init__(self, group_name, inviter, group_id=None, calendar_id=None):
        super().__init__(group_name)
        self.inviter = inviter
        self.group_id = group_id
        self.calendar_id = calendar_id

# A QStandardItem for tree widgets
class StandardItem(QtGui.QStandardItem):
    def __init__(self,  txt='', role=None, description=None, group_id=None, calendar_id=None, font_size=12, set_bold=False, color=Qt.QColor(255, 255, 255)):
        super().__init__()
        self.role = role
        self.description = description
        self.group_id = group_id
        self.calendar_id = calendar_id
        fnt = Qt.QFont('Open Sans', font_size)
        fnt.setBold(set_bold)
        self.setEditable(False)
        self.setForeground(color)
        self.setFont(fnt)
        self.setText(txt)



"""if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)

    main_window = QtWidgets.QMainWindow()
    ui = Main_Window()
    ui.setupUi(main_window)
    main_window.show()
    sys.exit(app.exec_())"""